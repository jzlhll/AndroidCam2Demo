package com.allan.cam2api.states;

import android.graphics.ImageFormat;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CaptureRequest;
import android.media.Image;
import android.media.ImageReader;
import android.util.Size;

import androidx.annotation.NonNull;

import com.allan.cam2api.base.ITakePictureCallback;
import com.allan.cam2api.MyCameraManager;
import com.allan.cam2api.states.image.IActionTakePicture;
import com.allan.cam2api.states.image.TakePictureBuilder;
import com.allan.cam2api.utils.CamLog;

import java.util.ArrayList;

public class StateBufferAndPicture extends AbstractStateBase implements ImageReader.OnImageAvailableListener, IActionTakePicture {
    public StateBufferAndPicture(MyCameraManager cd) {
        super(cd);
    }

    private ImageReader mPreviewBuffReader;
    private TakePictureBuilder mTakePic;

    @Override
    protected void step0_createSurfaces() {
        if (cameraManager.getCameraCharacteristics() == null) {
            throw new RuntimeException("No Camera Charact!");
        }
        addTargetSurfaces = new ArrayList<>();
        allIncludePictureSurfaces = new ArrayList<>();

        Size needSize = setSize(1920, 1080);
        if (mPreviewBuffReader == null) {
            //**** width和height要传入正确，否则，preview就变大小
            mPreviewBuffReader = ImageReader.newInstance(needSize.getWidth(), needSize.getHeight(), ImageFormat.YUV_420_888, 3); //最大的图片的个数
            mPreviewBuffReader.setOnImageAvailableListener(this, cameraManager.getHandler());
        }
        //预览Surface都加入
        addTargetSurfaces.add(mPreviewBuffReader.getSurface());
        allIncludePictureSurfaces.add(mPreviewBuffReader.getSurface());

        { //这个添加到allIncludePictureSurfaces 不需要添加到target里面
            mTakePic = new TakePictureBuilder(cameraManager, needSize.getWidth(), needSize.getHeight());
            allIncludePictureSurfaces.add(mTakePic.getSurface());
        }
    }

    @Override
    protected int step1_getTemplateType() {
        return CameraDevice.TEMPLATE_STILL_CAPTURE;
    }

    @Override
    public int getFeatureId() {
        return FeatureUtil.FEATURE_PICTURE;
    }

    @Override
    public void closeSession() {
        if (mPreviewBuffReader != null)
            mPreviewBuffReader.close();
        mTakePic.release();
        super.closeSession();
    }

    @Override
    protected CameraCaptureSession.StateCallback createCameraCaptureSessionStateCallback() {
        return new CameraCaptureSession.StateCallback() {
            @Override
            public void onConfigured(@NonNull CameraCaptureSession session) {
                cameraManager.setCamSession(session);
                cameraManager.getPreviewBuilder().set(CaptureRequest.CONTROL_AF_MODE,
                        CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
                //camera.previewBuilder.set(CaptureRequest.JPEG_THUMBNAIL_SIZE, new Size(1080, 1920));
                try {
                    cameraManager.getCamSession().setRepeatingRequest(cameraManager.getPreviewBuilder().build(),
                            null, cameraManager.getHandler());
                } catch (CameraAccessException e) {
                    e.printStackTrace();
                }
                if (mStateBaseCb != null) {
                    StatePreview.IStatePreviewCallback cb = (StatePreview.IStatePreviewCallback) mStateBaseCb;
                    cb.onPreviewSucceeded();
                }
            }

            @Override
            public void onConfigureFailed(@NonNull CameraCaptureSession session) {
                CamLog.e("Error Configure Preview!");
                if (mStateBaseCb != null) {
                    StatePreview.IStatePreviewCallback cb = (StatePreview.IStatePreviewCallback) mStateBaseCb;
                    cb.onPreviewFailed();
                }
            }
        };
    }

    @Override
    public void onImageAvailable(ImageReader reader) {
        Image img = reader.acquireLatestImage();
        if (img != null) {
            //CamLog.d("onImage Available img fmt=" + img.getFormat() + " " );
            img.close();
        }
        //cameraManager.getHandler().post(new ImageSaverRunnable(reader.acquireNextImage(), mFile));
    }

    @Override
    public void takePicture(String dir, String name, ITakePictureCallback callback) {
        mTakePic.takePicture(dir, name, callback);
    }
}

